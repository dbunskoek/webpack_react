<html><head><title>From Notes to Kanban / SurviveJS - Survive the jungles of JavaScript</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="../../">Home</a></div><div class="nav__link"><a href="../../webpack_react">Table of Contents</a></div></nav></div><main role="main"><div class="post"><div class="header-image" style="background-image:url(/images/kanban_photo.jpg);"></div><h1 class="post__heading">From Notes to Kanban</h1><div class="post__content"><div><p><img src="/images/kanban.png" alt="Kanban board"></p>
<p>So far we have managed to set up a nice little development environment and develop an application for keeping track of notes in <code>localStorage</code>. We have still work to do in order to turn this into a real Kanban as pictured above.</p>
<p>Most importantly our system is missing the concept of Lane. A Lane is something that should be able to contain multiple Notes within itself. In the current system that is implicit. We&apos;ll need to extract that into a component of its own.</p>
<h2 id="extracting-lanes">Extracting Lanes<a class="header-anchor" href="#extracting-lanes">#</a></h2>
<p>As earlier we can use the same idea of two components here. There will be a component for higher level (ie. <code>Lanes</code>) and for lower level (ie. <code>Lane</code>). The higher level component will deal with aspects such as persistency and lane ordering. An individual <code>Lane</code> will just render its contents (ie. name and <code>Notes</code>) and provide basic manipulation operations as needed.</p>
<p>As a first step we will need to make some room for <code>Lanes</code> at our <code>App</code> level. Consider the example below:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import alt from &apos;../libs/alt&apos;;
import Lanes from &apos;./Lanes&apos;;
import LaneActions from &apos;../actions/LaneActions&apos;;
import LaneStore from &apos;../stores/LaneStore&apos;;
import persist from &apos;../decorators/persist&apos;;
import {storage, storageName, getInitialData} from &apos;../libs/storage&apos;;

@persist(storage, storageName, () =&gt; JSON.parse(alt.takeSnapshot()))
<span class="hljs-built_in">export</span> default class App extends React.Component {
  <span class="hljs-function"><span class="hljs-title">constructor</span></span>() {
    super();

    LaneActions.init(getInitialData(&apos;LaneStore&apos;));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div&gt;
        &lt;button onClick={this.addLane}&gt;+&lt;/button&gt;
        &lt;AltContainer
          stores={[LaneStore]}
          inject={{
            items: () =&gt; LaneStore.getState().lanes || [],
          }}
        &gt;
          &lt;Lanes /&gt;
        &lt;/AltContainer&gt;
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addLane</span></span>() {
    LaneActions.create(&apos;New lane&apos;);
  }
}
</code></pre>
<p>Note that the implementation of <code>../libs/storage</code> has been changed to make it easier to operate on it through a more complex hierarchy. We&apos;ll need this later when we attach more stores to the system.</p>
<p><strong>app/libs/storage.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storageName = &apos;kanban_storage&apos;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storage = {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(k));
    }
    <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) </span>{
    localStorage.setItem(k, <span class="hljs-built_in">JSON</span>.stringify(v));
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInitialData</span>(<span class="hljs-params">storeName</span>) </span>{
  <span class="hljs-keyword">var</span> o = storage.get(storageName);

  <span class="hljs-keyword">return</span> o &amp;&amp; o[storeName];
}
</code></pre>
<p>Just to get the code compile here are initial implementations for some new actions and a store.</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> &apos;../libs/alt&apos;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneActions</span> </span>{
  init(lanes) {
    <span class="hljs-keyword">this</span>.dispatch(lanes);
  }
  create(name) {
    <span class="hljs-keyword">this</span>.dispatch(name);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createActions(LaneActions);
</code></pre>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> &apos;../libs/alt&apos;;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> &apos;../actions/LaneActions&apos;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(LaneActions);
  }
  init(data) {
    <span class="hljs-keyword">this</span>.setState(data || {lanes: []});
  }
  create(name) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;

    <span class="hljs-keyword">this</span>.setState({
      lanes: lanes.concat({
        name: name,
      })
    });
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, &apos;LaneStore&apos;);
</code></pre>
<p>The idea is the same as before with lanes. We are also going to need that <code>Lanes</code> container.</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript">import React from &apos;react&apos;;

<span class="hljs-built_in">export</span> default class Lanes extends React.Component {
  constructor(props: {
    items: Array;
  }) {
    super(props);
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div className=&apos;lanes&apos;&gt;
        lanes should go here
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>The current implementation doesn&apos;t do much. We still need to model <code>Lane</code> and attach <code>Notes</code> to that.</p>
<h2 id="modeling-lane-">Modeling <code>Lane</code><a class="header-anchor" href="#modeling-lane-">#</a></h2>
<p>To start with a <code>Lane</code> is pretty much what our <code>App</code> was earlier. This time around we&apos;ll want to render a header that contains name and a control for adding new notes within it.</p>
<p>First of all let&apos;s extend the <code>render</code> method of <code>Lanes</code> to make some room for individual lanes:</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript">import React from &apos;react&apos;;

import Lane from &apos;./Lane&apos;;

<span class="hljs-built_in">export</span> default class Lanes extends React.Component {
  constructor(props: {
    items: Array;
  }) {
    super(props);
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div className=&apos;lanes&apos;&gt;{this.props.items.map((lane, i) =&gt;
          &lt;Lane className=&apos;lane&apos; key={&apos;lane-&apos; + i} i={i} {...lane} /&gt;
      )}&lt;/div&gt;
    );
  }
}
</code></pre>
<p>Next we can model <code>Lane</code> based on our earlier work with <code>App</code>.</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import Notes from &apos;./Notes&apos;;
import NoteActions from &apos;../actions/NoteActions&apos;;
import NoteStore from &apos;../stores/NoteStore&apos;;

<span class="hljs-built_in">export</span> default class Lane extends React.Component {
  constructor(props: {
    name: string;
    i: number;
  }) {
    super(props);

    NoteActions.init();
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    /* eslint-disable no-unused-vars */
    const {i, name, ...props} = this.props;
    /* eslint-enable no-unused-vars */

    <span class="hljs-built_in">return</span> (
      &lt;div {...props}&gt;
        &lt;div className=&apos;lane-header&apos;&gt;
          &lt;div className=&apos;lane-name&apos;&gt;{name}&lt;/div&gt;
          &lt;div className=&apos;lane-add-note&apos;&gt;
            &lt;button onClick={this.addNote.bind(this)}&gt;+&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;AltContainer
          stores={[NoteStore]}
          inject={{
            items: () =&gt; NoteStore.getState().notes || [],
          }}
        &gt;
          &lt;Notes onEdit={this.noteEdited.bind(this)} /&gt;
        &lt;/AltContainer&gt;
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addNote</span></span>() {
    NoteActions.create(&apos;New note&apos;);
  }
  noteEdited(id, note) {
    <span class="hljs-keyword">if</span>(note) {
      NoteActions.update(id, note);
    }
    <span class="hljs-keyword">else</span> {
      NoteActions.remove(id);
    }
  }
}
</code></pre>
<p>Now we have something that sort of works. You can see there&apos;s something seriously wrong, though. If you add new Notes to a Lane, the Note appears to each Lane. Also if you modify a Note, also other Lanes update. In addition created Notes aren&apos;t persisted correctly. Just Lane data appears to get saved.</p>
<p>The reason why this happens is quite simple. Currently out <code>NoteStore</code> is a singleton. Even though this behavior is often convenient, it&apos;s definitely not the right for our application. We&apos;ll need to convert those singletons into separate instances.</p>
<h2 id="going-from-note-singletons-to-instances">Going from Note Singletons to Instances<a class="header-anchor" href="#going-from-note-singletons-to-instances">#</a></h2>
<p>A good first step towards getting rid of our Note singletons is to make our <code>NoteStore</code> more generic. We simply need to remove its direct dependency on Alt. Consider the code below:</p>
<p><strong>app/stores/NoteStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteStore</span> </span>{
  constructor(actions: <span class="hljs-built_in">Object</span>) {
    <span class="hljs-keyword">this</span>.bindActions(actions);
  }
  ...
}
</code></pre>
<p><strong>app/actions/NoteActions.js</strong></p>
<p><code>NoteActions</code> require similar treatment as well. Otherwise we&apos;ll end up transmitting the same signal to all of our stores are back to square one.</p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteActions</span> </span>{
  init(notes) {
    <span class="hljs-keyword">this</span>.dispatch(notes);
  }
  create(task) {
    <span class="hljs-keyword">this</span>.dispatch(task);
  }
  update(id, task) {
    <span class="hljs-keyword">this</span>.dispatch({id, task});
  }
  remove(id) {
    <span class="hljs-keyword">this</span>.dispatch(id);
  }
}
</code></pre>
<p>To make it all work together we need to tweak <code>Lane</code> to maintain actions and a store.</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import alt from &apos;../libs/alt&apos;;
import {getInitialData} from &apos;../libs/storage&apos;;
import Notes from &apos;./Notes&apos;;
import NoteActions from &apos;../actions/NoteActions&apos;;
import NoteStore from &apos;../stores/NoteStore&apos;;

<span class="hljs-built_in">export</span> default class Lane extends React.Component {
  constructor(props: {
    name: string;
    i: number;
  }) {
    super(props);

    this.actions = alt.createActions(NoteActions);

    const storeName = &apos;NoteStore-&apos; + this.props.i;
    this.store = alt.createStore(NoteStore, storeName, this.actions);
    this.actions.init(getInitialData(storeName));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    /* eslint-disable no-unused-vars */
    const {i, name, ...props} = this.props;
    /* eslint-enable no-unused-vars */

    <span class="hljs-built_in">return</span> (
      &lt;div {...props}&gt;
      ...
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addNote</span></span>() {
    this.actions.create(&apos;New note&apos;);
  }
  noteEdited(id, note) {
    <span class="hljs-keyword">if</span>(note) {
      this.actions.update(id, note);
    }
    <span class="hljs-keyword">else</span> {
      this.actions.remove(id);
    }
  }
</code></pre>
<h2 id="conclusion">Conclusion<a class="header-anchor" href="#conclusion">#</a></h2>
<p>If you run the application now, you should have something quite functional together! Even persistency works. It definitely is an eyesore still and we&apos;re missing some functionality like moving notes from a lane to lane. Before getting further on that let&apos;s take a little break and study various ways to style applications in React.</p>
</div></div><div class="header-extra"><a href="https://www.flickr.com/photos/61745819@N00/10588140955">Radek Orszewski (CC BY-NC-ND)</a></div><div class="prevnext"><div class="prevnext__prev"><div class="prevnext__bg" style="background-image:url(/images/delorean.jpg);"></div><span class="prevnext__info">Previous chapter</span><a class="prevnext__link" href="/webpack_react/react_and_flux">React and Flux</a></div><div class="prevnext__next"><div class="prevnext__bg" style="background-image:url(/images/taxi.jpg);"></div><span class="prevnext__info">Next chapter</span><a class="prevnext__link" href="/webpack_react/styling_react">Styling React</a></div></div></div><noscript></noscript><div class="prevnext-pages"><a href="../react_and_flux" class="previous-page">React and Flux</a><a href="../styling_react" class="next-page">Styling React</a></div></main></div></body></html>