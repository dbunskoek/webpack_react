<html><head><title>From Notes to Kanban / SurviveJS - Webpack and React</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="/">Home</a></div><div class="nav__link"><a href="/webpack_react">Table of Contents</a></div><div class="nav__link"><a href="https://leanpub.com/survivejs_webpack">Buy the ebook</a></div></nav></div><main role="main"><div class="post"><div class="docs-nav__wrapper docs-nav__wrapper--push-down"><h4 class="docs-nav--header">Table of Contents</h4><div class="docs-nav"><a href="/webpack_react/introduction" class="docs-nav__link">Introduction</a><a href="/webpack_react/webpack_compared" class="docs-nav__link">Webpack Compared</a><a href="/webpack_react/getting_started" class="docs-nav__link">Getting Started</a><a href="/webpack_react/developing_with_webpack" class="docs-nav__link">Developing with Webpack</a><a href="/webpack_react/linting_in_webpack" class="docs-nav__link">Linting in Webpack</a><a href="/webpack_react/webpack_and_react" class="docs-nav__link">Webpack and React</a><a href="/webpack_react/implementing_notes" class="docs-nav__link">Implementing a Basic Note App</a><a href="/webpack_react/react_and_flux" class="docs-nav__link">React and Flux</a><span class="docs-nav__link docs-nav__link--current">From Notes to Kanban</span><a href="/webpack_react/styling_react" class="docs-nav__link">Styling React</a><a href="/webpack_react/polishing_kanban" class="docs-nav__link">Polishing Kanban</a><a href="/webpack_react/deploying_applications" class="docs-nav__link">Deploying Applications</a><a href="/webpack_react/authoring_libraries" class="docs-nav__link">Authoring Libraries</a></div></div><div class="header-image" style="background-image:url(/images/kanban_photo.jpg);"></div><h1 class="post__heading">From Notes to Kanban</h1><div class="post__content"><div><p><img src="/images/kanban.png" alt="Kanban board"></p>
<p>So far we have managed to set up a nice little development environment and develop an application for keeping track of notes in <code>localStorage</code>. We have still work to do in order to turn this into a real Kanban as pictured above.</p>
<p>Most importantly our system is missing the concept of Lane. A Lane is something that should be able to contain multiple Notes within itself. In the current system that is implicit. We&apos;ll need to extract that into a component of its own.</p>
<h2 id="extracting-lanes">Extracting Lanes<a class="header-anchor" href="#extracting-lanes">#</a></h2>
<p>As earlier we can use the same idea of two components here. There will be a component for higher level (ie. <code>Lanes</code>) and for lower level (ie. <code>Lane</code>). The higher level component will deal with aspects such as persistency and lane ordering. An individual <code>Lane</code> will just render its contents (ie. name and <code>Notes</code>) and provide basic manipulation operations as needed.</p>
<p>As a first step we will need to make some room for <code>Lanes</code> at our <code>App</code> level. Consider the example below:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import alt from &apos;../libs/alt&apos;;
import Lanes from &apos;./Lanes&apos;;
import LaneActions from &apos;../actions/LaneActions&apos;;
import LaneStore from &apos;../stores/LaneStore&apos;;
import persist from &apos;../decorators/persist&apos;;
import {storage, storageName, getInitialData} from &apos;../libs/storage&apos;;

@persist(storage, storageName, () =&gt; JSON.parse(alt.takeSnapshot()))
<span class="hljs-built_in">export</span> default class App extends React.Component {
  <span class="hljs-function"><span class="hljs-title">constructor</span></span>() {
    super();

    LaneActions.init(getInitialData(&apos;LaneStore&apos;));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div&gt;
        &lt;button onClick={this.addLane}&gt;+&lt;/button&gt;
        &lt;AltContainer
          stores={[LaneStore]}
          inject={{
            items: () =&gt; LaneStore.getState().lanes || [],
          }}
        &gt;
          &lt;Lanes /&gt;
        &lt;/AltContainer&gt;
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addLane</span></span>() {
    LaneActions.create(&apos;New lane&apos;);
  }
}
</code></pre>
<p>Note that the implementation of <code>../libs/storage</code> has been changed to make it easier to operate on it through a more complex hierarchy. We&apos;ll need this later when we attach more stores to the system.</p>
<p><strong>app/libs/storage.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storageName = &apos;kanban_storage&apos;;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> storage = {
  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) </span>{
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(k));
    }
    <span class="hljs-keyword">catch</span>(e) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
    }
  },
  set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">k, v</span>) </span>{
    localStorage.setItem(k, <span class="hljs-built_in">JSON</span>.stringify(v));
  }
};

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInitialData</span>(<span class="hljs-params">storeName</span>) </span>{
  <span class="hljs-keyword">var</span> o = storage.get(storageName);

  <span class="hljs-keyword">return</span> o &amp;&amp; o[storeName];
}
</code></pre>
<p>Just to get the code compile here are initial implementations for some new actions and a store.</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> &apos;../libs/alt&apos;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneActions</span> </span>{
  init(lanes) {
    <span class="hljs-keyword">this</span>.dispatch(lanes);
  }
  create(name) {
    <span class="hljs-keyword">this</span>.dispatch(name);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createActions(LaneActions);
</code></pre>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> &apos;../libs/alt&apos;;
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> &apos;../actions/LaneActions&apos;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneStore</span> </span>{
  constructor() {
    <span class="hljs-keyword">this</span>.bindActions(LaneActions);
  }
  init(data) {
    <span class="hljs-keyword">this</span>.setState(data || {lanes: []});
  }
  create(name) {
    <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;

    <span class="hljs-keyword">this</span>.setState({
      lanes: lanes.concat({
        name: name,
      })
    });
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createStore(LaneStore, &apos;LaneStore&apos;);
</code></pre>
<p>The idea is the same as before with lanes. We are also going to need that <code>Lanes</code> container.</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript">import React from &apos;react&apos;;

<span class="hljs-built_in">export</span> default class Lanes extends React.Component {
  constructor(props: {
    items: Array;
  }) {
    super(props);
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div className=&apos;lanes&apos;&gt;
        lanes should go here
      &lt;/div&gt;
    );
  }
}
</code></pre>
<p>The current implementation doesn&apos;t do much. We still need to model <code>Lane</code> and attach <code>Notes</code> to that.</p>
<h2 id="modeling-lane-">Modeling <code>Lane</code><a class="header-anchor" href="#modeling-lane-">#</a></h2>
<p>To start with a <code>Lane</code> is pretty much what our <code>App</code> was earlier. This time around we&apos;ll want to render a header that contains name and a control for adding new notes within it.</p>
<p>First of all let&apos;s extend the <code>render</code> method of <code>Lanes</code> to make some room for individual lanes:</p>
<p><strong>app/components/Lanes.jsx</strong></p>
<pre><code class="undefinedjavascript">import React from &apos;react&apos;;

import Lane from &apos;./Lane&apos;;

<span class="hljs-built_in">export</span> default class Lanes extends React.Component {
  constructor(props: {
    items: Array;
  }) {
    super(props);
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    <span class="hljs-built_in">return</span> (
      &lt;div className=&apos;lanes&apos;&gt;{this.props.items.map((lane, i) =&gt;
          &lt;Lane className=&apos;lane&apos; key={&apos;lane-&apos; + i} i={i} {...lane} /&gt;
      )}&lt;/div&gt;
    );
  }
}
</code></pre>
<p>Next we can model <code>Lane</code> based on our earlier work with <code>App</code>.</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import Notes from &apos;./Notes&apos;;
import NoteActions from &apos;../actions/NoteActions&apos;;
import NoteStore from &apos;../stores/NoteStore&apos;;

<span class="hljs-built_in">export</span> default class Lane extends React.Component {
  constructor(props: {
    name: string;
    i: number;
  }) {
    super(props);

    NoteActions.init();
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    /* eslint-disable no-unused-vars */
    const {i, name, ...props} = this.props;
    /* eslint-enable no-unused-vars */

    <span class="hljs-built_in">return</span> (
      &lt;div {...props}&gt;
        &lt;div className=&apos;lane-header&apos;&gt;
          &lt;div className=&apos;lane-name&apos;&gt;{name}&lt;/div&gt;
          &lt;div className=&apos;lane-add-note&apos;&gt;
            &lt;button onClick={this.addNote.bind(this)}&gt;+&lt;/button&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;AltContainer
          stores={[NoteStore]}
          inject={{
            items: () =&gt; NoteStore.getState().notes || [],
          }}
        &gt;
          &lt;Notes onEdit={this.noteEdited.bind(this)} /&gt;
        &lt;/AltContainer&gt;
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addNote</span></span>() {
    NoteActions.create(&apos;New note&apos;);
  }
  noteEdited(id, note) {
    <span class="hljs-keyword">if</span>(note) {
      NoteActions.update(id, note);
    }
    <span class="hljs-keyword">else</span> {
      NoteActions.remove(id);
    }
  }
}
</code></pre>
<p>Now we have something that sort of works. You can see there&apos;s something seriously wrong, though. If you add new Notes to a Lane, the Note appears to each Lane. Also if you modify a Note, also other Lanes update. In addition created Notes aren&apos;t persisted correctly. Just Lane data appears to get saved.</p>
<p>The reason why this happens is quite simple. Currently out <code>NoteStore</code> is a singleton. Even though this behavior is often convenient, it&apos;s definitely not the right for our application. We&apos;ll need to convert those singletons into separate instances.</p>
<h2 id="going-from-note-singletons-to-instances">Going from Note Singletons to Instances<a class="header-anchor" href="#going-from-note-singletons-to-instances">#</a></h2>
<p>A good first step towards getting rid of our Note singletons is to make our <code>NoteStore</code> more generic. We simply need to remove its direct dependency on Alt. Consider the code below:</p>
<p><strong>app/stores/NoteStore.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteStore</span> </span>{
  constructor(actions: <span class="hljs-built_in">Object</span>) {
    <span class="hljs-keyword">this</span>.bindActions(actions);
  }
  ...
}
</code></pre>
<p><strong>app/actions/NoteActions.js</strong></p>
<p><code>NoteActions</code> require similar treatment as well. Otherwise we&apos;ll end up transmitting the same signal to all of our stores are back to square one.</p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NoteActions</span> </span>{
  init(notes) {
    <span class="hljs-keyword">this</span>.dispatch(notes);
  }
  create(task) {
    <span class="hljs-keyword">this</span>.dispatch(task);
  }
  update(id, task) {
    <span class="hljs-keyword">this</span>.dispatch({id, task});
  }
  remove(id) {
    <span class="hljs-keyword">this</span>.dispatch(id);
  }
}
</code></pre>
<p>To make it all work together we need to tweak <code>Lane</code> to maintain actions and a store.</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">import AltContainer from &apos;alt/AltContainer&apos;;
import React from &apos;react&apos;;

import alt from &apos;../libs/alt&apos;;
import {getInitialData} from &apos;../libs/storage&apos;;
import Notes from &apos;./Notes&apos;;
import NoteActions from &apos;../actions/NoteActions&apos;;
import NoteStore from &apos;../stores/NoteStore&apos;;

<span class="hljs-built_in">export</span> default class Lane extends React.Component {
  constructor(props: {
    name: string;
    i: number;
  }) {
    super(props);

    this.actions = alt.createActions(NoteActions);

    const storeName = &apos;NoteStore-&apos; + this.props.i;
    this.store = alt.createStore(NoteStore, storeName, this.actions);
    this.actions.init(getInitialData(storeName));
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    /* eslint-disable no-unused-vars */
    const {i, name, ...props} = this.props;
    /* eslint-enable no-unused-vars */

    <span class="hljs-built_in">return</span> (
      &lt;div {...props}&gt;
      ...
      &lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">addNote</span></span>() {
    this.actions.create(&apos;New note&apos;);
  }
  noteEdited(id, note) {
    <span class="hljs-keyword">if</span>(note) {
      this.actions.update(id, note);
    }
    <span class="hljs-keyword">else</span> {
      this.actions.remove(id);
    }
  }
</code></pre>
<p>Now we have something that mostly works. We have separate lanes, you can add new notes to them and modify/remote them. There are still a few bits we&apos;re missing. Namely lane name editing and lane removal. Let&apos;s get those done next.</p>
<h2 id="implementing-edit-remove-for-lane-">Implementing Edit/Remove for <code>Lane</code><a class="header-anchor" href="#implementing-edit-remove-for-lane-">#</a></h2>
<p>We can follow the same idea as for <code>Note</code> here. Ie. if you click <code>Lane</code> name, it should become editable. In case the new name is empty, we&apos;ll simply remove it. Given it&apos;s the same behavior we can extract it from <code>Note</code> and then reuse at <code>Lane</code>.</p>
<p>Given <code>Note</code> already contains some of the logic we need, we can generalize the component. Simply rename <code>Note.jsx</code> as <code>Editable.jsx</code>. Make <code>Notes.jsx</code> point at <code>Editable</code> instead of <code>Note</code>.</p>
<p>Next we should replace <code>Lane</code> name to be rendered through <code>Editable</code>:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...

<span class="hljs-keyword">import</span> Editable <span class="hljs-keyword">from</span> &apos;./Editable&apos;;

...

&lt;Editable className=&apos;lane-name&apos; value={name}
  onEdit={<span class="hljs-keyword">this</span>.nameEdited.bind(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.props.i)} /&gt;

...

nameEdited(id, name) {
  <span class="hljs-built_in">console</span>.log(&apos;edited lane name&apos;, id, name);
}
</code></pre>
<p>If you try to edit a lane name now, you should see a console print. We still need some logic (ie. actions and store tweaks) to make this work. A good starting point is to sketch out the component level logic:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...
<span class="hljs-keyword">import</span> LaneActions <span class="hljs-keyword">from</span> &apos;../actions/LaneActions&apos;;

...

nameEdited(id, name) {
  <span class="hljs-keyword">if</span>(name) {
    LaneActions.update(i, name);
  }
  <span class="hljs-keyword">else</span> {
    LaneActions.remove(i);
  }
}
</code></pre>
<p>This is exactly the same logic as for notes. In fact it is be possible to factor the behavior into a method of its own. This can be done by extracting actions into a parameter. As duplication is root of all evil, let&apos;s change it to this form:</p>
<p><strong>app/components/Lane.jsx</strong></p>
<pre><code class="undefinedjavascript">...

&lt;Editable className=&apos;lane-name&apos; value={name}
  onEdit={<span class="hljs-keyword">this</span>.edited.bind(<span class="hljs-keyword">this</span>, LaneActions, <span class="hljs-keyword">this</span>.props.i)} /&gt;

...

&lt;Notes onEdit={<span class="hljs-keyword">this</span>.edited.bind(<span class="hljs-keyword">this</span>, <span class="hljs-keyword">this</span>.actions)} /&gt;

...

edited(actions, id, value) {
  <span class="hljs-keyword">if</span>(value) {
    actions.update(id, value);
  }
  <span class="hljs-keyword">else</span> {
    actions.remove(id);
  }
}
</code></pre>
<p>Now our editing logic in a single place. We could have done this modification later but this felt like a good place to do that. Sometimes it can be justified to get rid of duplicates and push them to methods, components or decorators. We are still missing some of the logic to make <code>Lane</code> edit/remove work, though. To achieve that we need to extend <code>Lane</code> actions and store.</p>
<p><strong>app/actions/LaneActions.js</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">import</span> alt <span class="hljs-keyword">from</span> &apos;../libs/alt&apos;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LaneActions</span> </span>{
  init(lanes) {
    <span class="hljs-keyword">this</span>.dispatch(lanes);
  }
  create(name) {
    <span class="hljs-keyword">this</span>.dispatch(name);
  }
  update(id, name) {
    <span class="hljs-keyword">this</span>.dispatch({id, name});
  }
  remove(id) {
    <span class="hljs-keyword">this</span>.dispatch(id);
  }
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> alt.createActions(LaneActions);
</code></pre>
<p>It&apos;s the same idea as for <code>NoteActions</code> apart from the way we instantiate the stores. It would be possible to extract the instantiation logic from here as well. That could be a good idea especially if you want to have multiple boards in your application.</p>
<p>One radical option would be to use the same base class for both <code>LaneActions</code> and <code>NoteActions</code> but that feels like a premature optimization as it is difficult to say how these APIs might evolve. Some amount of duplication can be acceptable.</p>
<p>We still need those <code>LaneStore</code> methods. Not surprisingly it&apos;s going to be very similar <code>NoteStore</code> implementation. Again, a possible place to clean up later.</p>
<p><strong>app/stores/LaneStore.js</strong></p>
<pre><code class="undefinedjavascript">...

update({id, name}) {
  <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;

  lanes[id].name = name;

  <span class="hljs-keyword">this</span>.setState({
    lanes: lanes,
  });
}
remove(id) {
  <span class="hljs-keyword">const</span> lanes = <span class="hljs-keyword">this</span>.lanes;

  <span class="hljs-keyword">this</span>.setState({
    lanes: lanes.slice(<span class="hljs-number">0</span>, id).concat(lanes.slice(id + <span class="hljs-number">1</span>)),
  });
}
</code></pre>
<p>After these changes you should be able to modify lane names and remove lanes. Even persistency should just work without requiring any further tweaking. The implementation could be trimmed and some code could be removed but for now it&apos;s nice to have some room to maneuver. Who knows what sort of requirements might come up after all.</p>
<h2 id="conclusion">Conclusion<a class="header-anchor" href="#conclusion">#</a></h2>
<p>In this chapter we managed to generalize our application somehow. We actually have something you can sort of use! It&apos;s not pretty and the user experience is quite horrible. Still, it&apos;s better than before. Before focusing on advanced functionality let&apos;s try to make the application look a little better and study some styling approaches.</p>
</div></div></div><noscript></noscript><div class="prevnext-pages"><a href="../react_and_flux" class="previous-page">React and Flux</a><a href="../styling_react" class="next-page">Styling React</a></div></main></div></body></html>