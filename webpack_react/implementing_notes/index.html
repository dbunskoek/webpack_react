<html><head><title>Implementing a Basic Note App / SurviveJS - Webpack and React</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><link rel="icon" type="image/png" href="../../assets/img/favicon.png"><link rel="stylesheet" href="../../assets/main.css"></head><body><div><div class="nav__wrapper"><input type="checkbox" class="nav__toggle" id="nav__toggle"><label class="nav__toggle-label" for="nav__toggle"></label><nav class="nav"><div class="nav__link"><a href="/">Home</a></div><div class="nav__link"><a href="/webpack_react">Table of Contents</a></div><div class="nav__link"><a href="https://leanpub.com/survivejs_webpack">Buy the ebook</a></div></nav></div><main role="main"><div class="post"><div class="docs-nav__wrapper"><h4 class="docs-nav--header">Table of Contents</h4><div class="docs-nav"><a href="/webpack_react/introduction" class="docs-nav__link">Introduction</a><a href="/webpack_react/webpack_compared" class="docs-nav__link">Webpack Compared</a><a href="/webpack_react/getting_started" class="docs-nav__link">Getting Started</a><a href="/webpack_react/developing_with_webpack" class="docs-nav__link">Developing with Webpack</a><a href="/webpack_react/linting_in_webpack" class="docs-nav__link">Linting in Webpack</a><a href="/webpack_react/webpack_and_react" class="docs-nav__link">Webpack and React</a><span class="docs-nav__link docs-nav__link--current">Implementing a Basic Note App</span><a href="/webpack_react/react_and_flux" class="docs-nav__link">React and Flux</a><a href="/webpack_react/from_notes_to_kanban" class="docs-nav__link">From Notes to Kanban</a><a href="/webpack_react/styling_react" class="docs-nav__link">Styling React</a><a href="/webpack_react/polishing_kanban" class="docs-nav__link">Polishing Kanban</a><a href="/webpack_react/deploying_applications" class="docs-nav__link">Deploying Applications</a><a href="/webpack_react/authoring_libraries" class="docs-nav__link">Authoring Libraries</a></div></div><div class="header-image" style="background-image:url(/images/notes.jpg);"></div><h1 class="post__heading">Implementing a Basic Note App</h1><div class="post__content"><div><p>Given we have a nice development setup now, we can actually get some work done. Our goal here is to end up with a crude Note List with basic manipulation operations. Hit <code>npm start</code>. It&apos;s time to start developing.</p>
<h2 id="extending-note">Extending Note<a class="header-anchor" href="#extending-note">#</a></h2>
<p>A good first step would be to extend <code>Note</code> interface. We would probably want to render a list of these. Ideally we should be able to perform basic editing operations over the list and create new items as needed. We&apos;ll probably also want to mark items as done.</p>
<p>This means <code>App</code> will have to coordinate the state. Let&apos;s start by rendering a list and then expand from there. Here&apos;s sample code for an enhanced <code>render</code> method:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-function"><span class="hljs-title">render</span></span>() {
  var notes = [{
    task: &apos;Learn Webpack&apos;,
  }, {
    task: &apos;Learn React&apos;,
  }, {
    task: &apos;Do laundry&apos;,
  }];

  <span class="hljs-built_in">return</span> (
    &lt;div&gt;
      &lt;ul&gt;{notes.map((note, i) =&gt;
        &lt;li key={&apos;note&apos; + i}&gt;
          &lt;Note task={note.task} /&gt;
        &lt;/li&gt;
      )}&lt;/ul&gt;
    &lt;/div&gt;
  );
}
</code></pre>
<p>We will use a special feature of JSX in form of <code>{}</code>. Within these braces we can mix JavaScript with JSX. In this case we will render a bunch of <code>li</code> elements. Each contains a <code>Note</code>. In order to tell React in which order to render the elements, we&apos;ll set <code>key</code> property for each. It is important that this is unique or otherwise it won&apos;t be able to figure out the correct order.</p>
<blockquote class="tip">If you want to attach comments to your JSX, just use <code>{/* no comments */}</code>.</blockquote><p>If everything went correctly, you should see a list with three <code>Learn Webpack</code> items on it. That&apos;s almost nice. The problem is that we haven&apos;t taken <code>task</code> property in count at <code>Note</code>. We&apos;ll need to tweak its implementation like this:</p>
<p><strong>app/components/Note.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-function"><span class="hljs-title">render</span></span>() {
  <span class="hljs-built_in">return</span> &lt;div&gt;{this.props.task}&lt;/div&gt;;
}
</code></pre>
<p>As you can see the property we passed to our component gets mapped to <code>this.props</code>. After that it is just a matter of showing it wherever we like.</p>
<p>We haven&apos;t achieved much yet but we&apos;re getting there. In order to get somewhere, we&apos;ll need to expand and refine our component hierarchy.</p>
<h2 id="refining-component-hierarchy">Refining Component Hierarchy<a class="header-anchor" href="#refining-component-hierarchy">#</a></h2>
<p>It is nice to keep the implementation of <code>App</code> on a high level. Currently there are concerns that might not belong there. We can improve the situation by splitting <code>Notes</code> into a component of its own. It will be just a component that takes <em>items</em> as an input and renders them as above.</p>
<p>We&apos;ll want to end up a hierarchy such as this: App -&gt; Notes -&gt; Note. Each of these components will map to a file within <code>components</code>. Our <code>Note</code> is fine as is. <code>Notes</code> needs to be extracted out of <code>App</code>. Here&apos;s a sample implementation:</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="undefinedjavascript">import React from &apos;react&apos;;
import Note from &apos;./Note&apos;;

<span class="hljs-built_in">export</span> default class Notes extends React.Component {
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    var notes = this.props.items;

    <span class="hljs-built_in">return</span> (
      &lt;ul className=&apos;notes&apos;&gt;{notes.map((note, i) =&gt;
        &lt;li className=&apos;note&apos; key={&apos;note&apos; + i}&gt;
          &lt;Note task={note.task} /&gt;
        &lt;/li&gt;
      )}&lt;/ul&gt;
    );
  }
}
</code></pre>
<p>I attached some classes there so it&apos;s easier to style the component later.</p>
<p>Remember to replace the old list with <code>&lt;Notes items={notes} /&gt;</code> at <em>App.jsx</em>:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">import Notes from &apos;./Notes&apos;;

...
<span class="hljs-function"><span class="hljs-title">render</span></span>() {
  ...

  <span class="hljs-built_in">return</span> (
    &lt;div&gt;
      &lt;Notes items={notes} /&gt;
    &lt;/div&gt;
  );
}
...
</code></pre>
<p>Not only this change keeps <code>App</code> cleaner but it also gives us flexibility. If you wanted to have multiple <code>Notes</code> lists, it would be simple now. This is one of the key things to understand about React. You will need to learn to think in terms of components.</p>
<h2 id="adding-new-items-to-notes-list">Adding New Items to Notes list<a class="header-anchor" href="#adding-new-items-to-notes-list">#</a></h2>
<p>It would be useful if we could add new items to our Notes list. Let&apos;s just do a plus button that adds a new dummy item to our list.</p>
<p>To get a button show up, change <code>render</code> method like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-function"><span class="hljs-title">render</span></span>() {
  ...

  <span class="hljs-built_in">return</span> (
    &lt;div&gt;
      &lt;button onClick={this.addItem.bind(this)}&gt;+&lt;/button&gt;
      &lt;Notes items={notes} /&gt;
    &lt;/div&gt;
  );
}
<span class="hljs-function"><span class="hljs-title">addItem</span></span>() {
  console.log(&apos;add item&apos;);
}
</code></pre>
<p>Now when you click the button, you should see something at your browser console.</p>
<h2 id="connecting-additem-with-data-model">Connecting <code>addItem</code> with Data Model<a class="header-anchor" href="#connecting-additem-with-data-model">#</a></h2>
<p>Next we will need to connect this with our data model somehow. It is problematic that data is stored within our <code>render</code> method. React provides a concept known as state for this purpose. We can move our data there like this:</p>
<pre><code class="undefinedjavascript">constructor(props) {
  <span class="hljs-keyword">super</span>(props);

  <span class="hljs-keyword">this</span>.state = {
    notes: [{
      task: &apos;Learn Webpack&apos;,
    }, {
      task: &apos;Learn React&apos;,
    }, {
      task: &apos;Do laundry&apos;,
    }],
  };
}
render() {
  <span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">this</span>.state.notes;
  ...
}
</code></pre>
<p>Now our <code>render</code> method points at <code>state</code>. As a result we can implement <code>addItem</code> that actually does something useful:</p>
<pre><code class="undefinedjavascript">addItem() {
  <span class="hljs-keyword">this</span>.setState({
    notes: <span class="hljs-keyword">this</span>.state.notes.concat([{
      task: &apos;New task&apos;,
    }])
  });
}
</code></pre>
<p>If you hit the button now, you should see new items. It might not be pretty yet but it works.</p>
<h2 id="editing-notes">Editing Notes<a class="header-anchor" href="#editing-notes">#</a></h2>
<p>Our Notes list is almost useful now. It is a little unfortunate that even though we can add new items to the list, we cannot modify them. It is time to implement edit.</p>
<p>A natural way to do this would be to allow the user to click an item. When an item is clicked, it would be replaced with an input control that would allow you to edit. After confirmed, the modification should remain there.</p>
<p>This means we&apos;ll need to extend <code>Note</code> somehow and communicate possible changes to <code>App</code> so that it knows to update the data model. In addition <code>Note</code> needs to keep track of its edit state and show the correct element (div or input) based on that.</p>
<p>We can achieve these goals using a callback and a ternary expression. Here&apos;s a sample implementation of the idea:</p>
<p><strong>app/components/Note.jsx</strong></p>
<pre><code class="undefinedjavascript"><span class="hljs-built_in">export</span> default class Note extends React.Component {
  constructor(props) {
    super(props);

    this.state = {
      edited: <span class="hljs-literal">false</span>,
    };
  }
  <span class="hljs-function"><span class="hljs-title">render</span></span>() {
    var edited = this.state.edited;
    var task = this.props.task;

    <span class="hljs-built_in">return</span> (
      &lt;div&gt;{
        edited
        ? &lt;input <span class="hljs-built_in">type</span>=&apos;text&apos;
          defaultValue={task}
          onBlur={this.finishEdit.bind(this)}
          onKeyPress={this.checkEnter.bind(this)}/&gt;
        : &lt;div onClick={this.edit.bind(this)}&gt;{task}&lt;/div&gt;
      }&lt;/div&gt;
    );
  }
  <span class="hljs-function"><span class="hljs-title">edit</span></span>() {
    this.setState({
        edited: <span class="hljs-literal">true</span>,
    });
  }
  checkEnter(e) {
    <span class="hljs-keyword">if</span>(e.key === &apos;Enter&apos;) {
      this.finishEdit(e);
    }
  }
  finishEdit(e) {
    this.props.onEdit(e.target.value);

    this.setState({
      edited: <span class="hljs-literal">false</span>,
    });
  }
}
</code></pre>
<p>It&apos;s a lot of code to digest. <code>Note</code> has <em>edited</em> state to keep track of. We will manipulate that to change the way it is rendered. If we hit <strong>edit</strong>, we&apos;ll trigger edit mode. Once input receives either <em>blur</em> event or Enter key, we&apos;ll finish editing and reset the value. When finishing we also trigger a callback so the app knows to react.</p>
<p>In order to make that happen we&apos;ll need to define that callback for <code>App</code> like this:</p>
<p><strong>app/components/App.jsx</strong></p>
<pre><code class="undefinedjavascript">render() {
  ...
  &lt;Notes
    items={notes}
    onEdit={<span class="hljs-keyword">this</span>.itemEdited.bind(<span class="hljs-keyword">this</span>)} /&gt;
  ...
}
itemEdited(i, task) {
  <span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">this</span>.state.notes;

  notes[i].task = task;

  <span class="hljs-keyword">this</span>.setState({
    notes: notes,
  });
}
</code></pre>
<p>We also need to tweak <code>Notes</code> like this:</p>
<p><strong>app/components/Notes.jsx</strong></p>
<pre><code class="undefinedjavascript">...
&lt;Note
  task={note.task}
  onEdit={<span class="hljs-keyword">this</span>.props.onEdit.bind(<span class="hljs-keyword">this</span>, i)} /&gt;
...
</code></pre>
<p>As you can see the nested hierarchy is starting to cause some subtle problems. We&apos;ll fix these later. Now we just want to get something to work. You should be able to edit todos now.</p>
<h2 id="removing-notes">Removing Notes<a class="header-anchor" href="#removing-notes">#</a></h2>
<p>We are still missing one vital functionality. It would be nice to be able to remove notes. We can achieve this easily by extending edit.</p>
<p>In case we empty a task, it would make sense to remove it. You can give it a go yourself or follow the example below. It is just a matter of modifying state.</p>
<pre><code class="undefinedjavascript">itemEdited(i, task) {
  <span class="hljs-keyword">var</span> notes = <span class="hljs-keyword">this</span>.state.notes;

  <span class="hljs-keyword">if</span>(task) {
    notes[i].task = task;
  }
  <span class="hljs-keyword">else</span> {
    notes = notes.slice(<span class="hljs-number">0</span>, i).concat(notes.slice(i + <span class="hljs-number">1</span>));
  }

  <span class="hljs-keyword">this</span>.setState({
    notes: notes,
  });
}
</code></pre>
<p>An alternative way would have been to render some sort of button for removing an item. When pressed it would have triggered similar logic. If you feel like it, give it a go. Just have something like <code>&lt;button onClick={this.removeItem.bind(null, i)}&gt;-&lt;/button&gt;</code> there, delete based on index and update state.</p>
<blockquote class="tip">We just introduced some interesting behavior to our system. Note that as we track edit state on <code>Note</code> level, this means if you remove an item before the edited <code>Note</code>, the same old element remains edited. If we want to edit specific data, our data model should change to take this in count. Can you see how?</blockquote><h2 id="adding-type-checking-with-flow">Adding Type Checking with Flow<a class="header-anchor" href="#adding-type-checking-with-flow">#</a></h2>
<p>As we saw earlier with <code>onEdit</code>, it gave us a nasty error before we actually defined a handler for the case. Thanks to <a href="http://flowtype.org/">Flow</a> and <a href="https://gcanti.github.io/flowcheck/">Flowcheck</a> we can add typing information to our source. This is very useful in a situation where you are working with large project and many developers. Just like with linting earlier this is one way to make your work more boring. Boring is still good!</p>
<p>We can set up Flow type checking to our Webpack easily by first doing <code>npm i flowcheck-loader --save-dev</code> and then extending our development configuration a little like this:</p>
<pre><code class="undefinedjavascript"><span class="hljs-keyword">if</span>(TARGET === &apos;dev&apos;) {
  <span class="hljs-built_in">module</span>.exports = mergeConfig({
    ...
    <span class="hljs-built_in">module</span>: {
      ...
      loaders: {
        {
          test: <span class="hljs-regexp">/\.jsx?$/</span>,
          loaders: [&apos;react-hot&apos;, &apos;babel&apos;, &apos;flowcheck&apos;],
          include: path.join(ROOT_PATH, &apos;app&apos;),
        },
      },
    },
    ...
  });
}
</code></pre>
<p>Now we can start typing. For instance you could attach types for <code>Note</code> props like this:</p>
<pre><code class="undefinedjavascript">constructor(props: {
  task: string;
  onEdit: <span class="hljs-built_in">Function</span>;
}) {...}
</code></pre>
<p><code>Notes</code> would look similar expect in that case we would perform an assertion like</p>
<pre><code class="undefinedjavascript">constructor(props: {
  items: <span class="hljs-built_in">Array</span>;
  onEdit: <span class="hljs-built_in">Function</span>;
}) {...}
</code></pre>
<p>With Flow you can type the most vital parts of your source. You can think it as an executable form of documentation that helps you during development. As with linting it won&apos;t replace tests but it will make it easier to work with the source. See <a href="https://tryflow.org/">Try Flow</a> for more concrete examples.</p>
<h2 id="conclusion">Conclusion<a class="header-anchor" href="#conclusion">#</a></h2>
<p>The approach we discussed works up to a point. It is a little ugly but it works. In the next chapter we will clean things up as we introduce Flux architecture and port our application to use it.</p>
</div></div></div><noscript></noscript><div class="prevnext-pages"><a href="../webpack_and_react" class="previous-page">Webpack and React</a><a href="../react_and_flux" class="next-page">React and Flux</a></div></main></div></body></html>